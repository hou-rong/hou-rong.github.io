<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MySql on 海纳百川，有容乃大</title>
    <link>https://hou-rong.github.io/tags/mysql/</link>
    <description>Recent content in MySql on 海纳百川，有容乃大</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 18 Jul 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://hou-rong.github.io/tags/mysql/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MySql 表，库大小查询</title>
      <link>https://hou-rong.github.io/post/mysql-%E8%A1%A8%E5%A4%A7%E5%B0%8F%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Tue, 18 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hou-rong.github.io/post/mysql-%E8%A1%A8%E5%A4%A7%E5%B0%8F%E6%9F%A5%E8%AF%A2/</guid>
      <description> 引入 在工作中，需要查询表的占用的空间以及数据库占用的空间
查询语句 查询每个数据库占用的空间的大小
SELECT table_schema, concat(round(sum(DATA_LENGTH/1024/1024),2),&#39;MB&#39;) as data FROM TABLES group by table_schema;  查询每个表占用空间的大小
SELECT table_name, concat(round(sum(DATA_LENGTH/1024/1024),2),&#39;MB&#39;) as data FROM TABLES where table_schema=&amp;quot;db name&amp;quot; group by table_name;  所有库和表的大小
SELECT table_schema, table_name, concat(round(sum(DATA_LENGTH/1024/1024),2),&#39;MB&#39;) as data FROM TABLES group by table_schema, table_name;  </description>
    </item>
    
    <item>
      <title>PhpMyAdmin Docker 配置</title>
      <link>https://hou-rong.github.io/post/phpmyadmin-docker-%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 16 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hou-rong.github.io/post/phpmyadmin-docker-%E9%85%8D%E7%BD%AE/</guid>
      <description>引入 在工作中经常需要进行数据库的查询，使用默认的命令行却不太好用。所有选择使用 PhpMyAdmin 进行图形化的搜索，由于不希望在本机安装太多服务程序，所以使用 Docker 管理 PhpMyAdmin 镜像。
安装 Docker 官网安装
安装镜像 docker pull phpmyadmin/phpmyadmin  配置 PhpMyAdmin config.user.inc.php 配置文件 &amp;lt;?php $connect_hosts = array( &#39;1&#39;=&amp;gt;array( &amp;quot;host&amp;quot; =&amp;gt; &amp;quot;Host 1&amp;quot;, // Server 1 ), &#39;2&#39; =&amp;gt; array( &amp;quot;host&amp;quot; =&amp;gt; &amp;quot;Host 2&amp;quot;, // Server 2 ); for ($i=1;$i&amp;lt;=count($connect_hosts);$i++) { /* Server parameters */ $cfg[&#39;Servers&#39;][$i][&#39;host&#39;] = $connect_hosts[$i][&#39;host&#39;]; //修改host $cfg[&#39;Servers&#39;][$i][&#39;connect_type&#39;] = &#39;tcp&#39;; $cfg[&#39;Servers&#39;][$i][&#39;compress&#39;] = false; /* Select mysqli if your server has it */ $cfg[&#39;Servers&#39;][$i][&#39;extension&#39;] = &#39;mysql&#39;; $cfg[&#39;Servers&#39;][$i][&#39;AllowNoPassword&#39;] = true; /* rajk - for blobstreaming */ $cfg[&#39;Servers&#39;][$i][&#39;bs_garbage_threshold&#39;] = 50; $cfg[&#39;Servers&#39;][$i][&#39;bs_repository_threshold&#39;] = &#39;32M&#39;; $cfg[&#39;Servers&#39;][$i][&#39;bs_temp_blob_timeout&#39;] = 600; $cfg[&#39;Servers&#39;][$i][&#39;bs_temp_log_threshold&#39;] = &#39;32M&#39;; }  使用外部配置开启服务 docker run --name myadmin -d -p 8080:80 -v /Users/hourong/Config/config.</description>
    </item>
    
    <item>
      <title>Python 使用 MySql 的分片的方式读取数据库中大量数据</title>
      <link>https://hou-rong.github.io/post/python-%E4%BD%BF%E7%94%A8-mysql-%E7%9A%84%E5%88%86%E7%89%87%E7%9A%84%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Thu, 15 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hou-rong.github.io/post/python-%E4%BD%BF%E7%94%A8-mysql-%E7%9A%84%E5%88%86%E7%89%87%E7%9A%84%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE/</guid>
      <description>引入 在工作过程中发现某些单条数据特别大的表，希望读取其中的全部数据，于是利用 MySql 的分片进行逐步读取。
函数主体 import gc import pymysql from pymysql.cursors import DictCursor __sql_dict = { &#39;host&#39;: &#39;&#39;, &#39;user&#39;: &#39; &#39;, &#39;passwd&#39;: &#39;&#39;, &#39;charset&#39;: &#39;utf8&#39;, &#39;db&#39;: &#39;&#39; } def get_data(table, source, step=10000): _conn = pymysql.connect(**__sql_dict) with _conn.cursor(cursor=DictCursor) as cursor: sql = &#39;select count(*) from {0} where source=&amp;quot;{1}&amp;quot;&#39;.format(table, source) cursor.execute(sql) total = list(cursor.fetchall()[0].values())[0] _count = 0 for start in range(0, total + 1, step): sql = &#39;select * from {0} where source=&amp;quot;{1}&amp;quot; limit {2},{3}&#39;.</description>
    </item>
    
    <item>
      <title>Mysql 备份脚本</title>
      <link>https://hou-rong.github.io/post/mysql-%E5%A4%87%E4%BB%BD%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Sat, 10 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hou-rong.github.io/post/mysql-%E5%A4%87%E4%BB%BD%E8%84%9A%E6%9C%AC/</guid>
      <description> 引入 在工作时没有自动备份 MySql 的习惯，直到有一次 Update 误操作 where 语句的范围写了一个为 True 的值，导致数据错误。还好通过之前的备份恢复，没损失多少数据，这也让我养成经常备份数据的习惯。
备份脚本 #!/bin/sh DUMP=/usr/bin/mysqldump OUT_DIR=/your/backup/dir/ LINUX_USER=root # 你的数据库信息 DB_NAME= DB_USER= DB_PASS= # 修改保存备份的日期 DAYS=7 cd $OUT_DIR DATE=`date +%Y_%m_%d_%H_%M_%S` OUT_SQL=&amp;quot;$DATE.sql&amp;quot; TAR_SQL=&amp;quot;xxxx_bak_$DATE.tar.gz&amp;quot; $DUMP -u$DB_USER -p$DB_PASS $DB_NAME --default-character-set=utf8 --opt -Q -R &amp;gt; $OUT_SQL tar -zcvf $TAR_SQL $OUT_SQL rm $OUT_SQL chown $LINUX_USER:$LINUX_USER $OUT_DIR/$TAR_SQL find $OUT_DIR -name &amp;quot;xxxx_bak*&amp;quot; -type f -mtime +$DAYS -exec rm {} \;  </description>
    </item>
    
  </channel>
</rss>